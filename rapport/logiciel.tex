\section{Repository architecture}

The general architecture of our code repository is explained in this tree :\\

\begin{figure}[!h] 
\begin{center}
\includegraphics[width=10cm]{imgs/c1.png}
\caption{1st part of the repository} 
\label{img1} 
\end{center}
\end{figure} 

In arduino\_sources folder, all the code related to the arduino board can be found.
The software used to program the arduino is expecting .pde or .ard files.\\

In the following parts, we will provide more details for each files.\\

The bluetooth folder contains C sources et headers used on the target to catch informations sent by the smartphone.\\

The embedded code section includes all the programs we created to run on the UAV embedded linux.\\

\newpage

\begin{figure}[!h] 
\begin{center}
\includegraphics[width=7cm]{imgs/c2.png}
\caption{2nd part of the repository} 
\label{img1} 
\end{center}
\end{figure} 

All the compiled modules we added on the embedded linux can be found in the module folder.\\

The ``rapport'' directory contains the sources of the documentation you are reading !\\

Finally, the most important folder is the one named sdk\_apps. It contains one application named auto\_flight. Like most of the c projects, you can find a Makefile, a bin/ and a src/ folder. The Makefile is configurated to create the application binary and to move it to the bin/ folder. You can find additionnal informations about the Makefile in the appedices.\\

About the src/ folder :\\

The most important C file is named ardrone\_testing\_tool.c. This file is making the link between our application and the ARdrone library. Moreover, it is launching and joining all our threads.\\

The Auto/ folder contains code related to the auto\_control thread.\\

The Avoidance/ folder contains code related to the avoidance thread.\\

The Comm/ folder contains code related to the receive\_gps thread.\\

The Comm\_target/ folder contains code related to the gps\_target thread.\\

The Control/ folder contains an small library we wrote to handle UAV travelling.\\

The GPS/ folder contains algorithms used to manipulate GPS strings and make distance and angle calculation.

The Navdata/ folder contains the fonctions used to read and store navdata sent by the UAV.\\

The STMachine/ folder contains the fonctions generated by SCADE KCG compiler.\\

The Target/ folder contains code related to the target thread.\\

\begin{figure}[!h] 
\begin{center}
\includegraphics[width=8cm]{imgs/c3.png}
\caption{3rd part of the repository} 
\label{img1} 
\end{center}
\end{figure} 

\newpage{}

\begin{tabular}{|l|l|l|}
    \hline
    Thread name & Period & Description \tabularnewline
    \hline
    ardrone\_control & 2 & Library related thread \tabularnewline
    \hline
    navdata\_update & 20 & Library related thread \tabularnewline
    \hline
    auto\_control & 20 & Thread allowing manual command of the UAV \tabularnewline
    \hline
    receive\_gps & 50 & Thread used to received gps coordinated sent by the UAV  \tabularnewline
    \hline
    avoidance & 60    & Thread used to perform autonomous obstacle avoidance   \tabularnewline
    \hline
    gps\_target & 50 & Thread used to received gps coordinated sent by the target  \tabularnewline
    \hline
    gps\_target & 50 & Thread used to perform autonomous convergence to the target  \tabularnewline
    \hline

 \end{tabular}

This table summarizes all the thread launched in our application. In the following sections, we will detail the operations of each threads.

\section{The auto thread}

The auto thread is mainly based on the movement API we developped with the Brown team.\\

\subsection{Movement API}

This API is an overlay of the Parrot API, it allows more intuitive UAV control. It also provide movement quatification, which means you can quantify an order by speed, distance or duration. For example, you can emit orders like ``go forward on 300 cm''.

\subsubsection{Les mouvements élémentaires}

Les commandes de déplacement sont définis dans le fichier Control/drone\_control.c, elles ont toutes le même format :

The travelling commands are all defined in the file Control/drone\_control.c, they have the same format :\\

\begin{lstlisting}
C_RESULT ordre (void *arg)
\end{lstlisting}

The list of available travellings :\\

\begin{itemize}

\item turn\_left 
\item turn\_right
\item forward    
\item backward   
\item up         
\item down       
\item right      
\item left       
\item stop       

\end{itemize}

\subsection{Send an order}

The above order can be passed to both functions depending on whether you want to make a move that will be termed ``elementary'', or a longer trip by specifying the distance.

\subsubsection{Elementary move}

An elementary movement allows for a sudden displacement of around 10 cm. You must use the following function:

\begin{lstlisting}
C_RESULT small_move(ORDER* order)
\end{lstlisting}

Sample code :\\

\begin{lstlisting}
small_move(turn_right);
\end{lstlisting}

\subsubsection{Long move}

All orders to send move commands accept an argument of type void *. This argument must be cast to void * but available commands manage only the type arguments mov\_t which includes different arguments :\\

\begin{lstlisting}
typedef struct mov_t{
  int32_t power;     //engine power between 0 and 100 
  int32_t distance;  //distance in cm
  int32_t time;      //time in usec
}mov;
\end{lstlisting}

Before sending orders, it's important to fill correctly this structure. Unused fields must be initialized to -1. To send an order, this function must be used :\\

\begin{lstlisting}
C_RESULT send_order(ORDER* order, void *arg)
\end{lstlisting}

Sample code :\\

\begin{lstlisting}
/* 30% on 70 cm*/
mov mv = {30, 70, -1};
send_order(backward, &mv);
\end{lstlisting}

\subsection{Using of this API}

In the auto thread, we need to control the UAV with the keyboard of the station. This automatic control is really useful in case of problems occuring during the automatic control.\\

Basically, we are just running a scanf in an infinite loop. Depeding on the key pressed, we just have to call the wright function of the API.\\

\begin{lstlisting}
  while (1) {
    usleep(100000);
    scanf("%c", &c);
    printf("%c\n",c);
    switch(c){
    case 'f':
      small_move(forward);
      break;
    case 'b':
      small_move(backward);
      break;
    case 'u':
      small_move(up);
      break;
    case 'd':
      small_move(down);
      break;
    case 'o':
      //small_move(left);
      printf("Batt :%d\n",sauv_ndata.bat_level_current);
      break;
\end{lstlisting}

Very helpful functionalities are battery control, by pressing the ``o'' key, and recover from emergency m
ode by pressing ``x''. All the other command are pretty basic (``land'', ``go up'', ``go down'').\\

\subsection{Storing navdatas}

We also use this thread to store the navdata received. To achieve this goal, it is necessary to declare three functions, defined in the ARDrone library :\\

\begin{lstlisting}
/* Initialization local variables before event loop  */
inline C_RESULT auto_navdata_client_init( void* data )

/* Receving navdata during the event loop */
inline C_RESULT auto_navdata_client_process( const navdata_unpacked_t* const navdata )

/* Relinquish the local resources after the event loop exit */
inline C_RESULT auto_navdata_client_release( void )
\end{lstlisting}

We just keep the informations we have to use later, like battery level, control state, altitude or psi angle.

\begin{lstlisting}
  sauv_ndata.psi_current = nd->psi / 1000;
  sauv_ndata.bat_level_current = nd->vbat_flying_percentage;
  sauv_ndata.ctrl_state_current = nd->ctrl_state;
  sauv_ndata.tag_detected = nv->nb_detected;
  sauv_ndata.tag_tab = nv->camera_source;
  sauv_ndata.alt = nd->altitude / 1000.0;
\end{lstlisting}

We store all these informations in a global structure that will be accessed by the other threads.

\section{The avoidance thread}

This thread is mainly based on SCADE generated code. The statechart modeling the avoidance is printed below :\\

\begin{figure}[!h] 
\begin{center}

\includegraphics[width=19cm]{imgs/scade.png}
\caption{SCADE statechart} 
\label{img1} 
\end{center}
\end{figure} 

Then, the KCG compiler gave us some independent code, that we included in our project.

\begin{lstlisting}
switch (AvoidMachine_state_sel) {
    case SSM_st_Travelling_AvoidMachine :
      outC->AvoidMachine_reset_act = inC->obstacle_detected;
      break;
    case SSM_st_Hovering_AvoidMachine :
      if (br_1_guard_AvoidMachine_Hovering) {
        outC->AvoidMachine_reset_act = 1;
      }
      else {
        outC->AvoidMachine_reset_act = br_2_guard_AvoidMachine_Hovering;
      }
      outC->init = 0;
      break;
    case SSM_st_Avoidance_up_AvoidMachine :
      if (inC->obstacle_detected) {
        outC->AvoidMachine_reset_act = 1;
      }
      else {
        outC->AvoidMachine_reset_act = br_2_guard_AvoidMachine_Avoidance_up;
      }
      outC->init2 = 0;
      break;
\end{lstlisting}

The top-level function is defined in the file IAvoid.h.

\begin{lstlisting}
extern void IAvoid(inC_IAvoid *inC, outC_IAvoid *outC);
\end{lstlisting}

The inputs of this statechart are a boolean named ``obstacle\_detected'' (its value is 1 if there is an obstacle and 0 otherwise) and 4 integers describing latencies between transitions.\\

The outputs are 5 booleans : 4 orders (up, down, stop, forward) and a neutral order (if there is nothing to do).\\

Each call to the function represent a cycle. We have planned to execute a cycle each 10ms. The following code is illustrating the use of the auto-generated function :\\

\begin{lstlisting}
DEFINE_THREAD_ROUTINE(avoidance, data) {
  
  comm_datas datas;
  double dangerThreshold=100;
  int detection;
  double average_left;
  int ret;

  init_array_obstacle_pos2();

  IAvoid_reset(&output);
  input.obstacle_detected = 0;
  input.latence1 = 100;
  input.latence2 = 100;
  input.latence3 = 300;
  input.latence4 = 100;

 while (1) {
   usleep(10);
   if (auto_ready) {
     //get srf datas
     datas = get_comm_datas();

     ret = average_obstacle_pos2(&datas.srfr, &average_left);
     printf("Moyenne capteur(%d) : %f\n", ret, average_left);

     //check threshold
     if (average_left < dangerThreshold) {
       detection = 1;
     } else {
       detection = 0;
     } 
   
     input.obstacle_detected = detection;     
     IAvoid(&input,&output);
     command(output);
     usleep(10000);    
   }
 }
 
  return (THREAD_RET) 0;
}
\end{lstlisting}

And the command function is :\\

\begin{lstlisting}
void command(outC_IAvoid comm) {
  mov speed;

  if (comm.up) {
    speed.power = 8;
    send_fast_order(up,(void *)&speed);
  } else if (comm.down) {
    speed.power = 3;
    send_fast_order(down,(void *)&speed);
  } else if (comm.stop) {
    send_fast_order(stop,NULL);
  } else if (comm.auto1) {
    speed.power = 1;
    printf("avance\n");
    send_fast_order(forward,(void *)&speed);
  } else if (comm.forward) {
    speed.power = 1;
    printf("avance\n");
    send_fast_order(forward,(void *)&speed);
  }

}
\end{lstlisting}

\section{The receive\_gps \& gps\_target threads}

Those threads are designed to receive and store the GPS strings sent by UAV and Target. The receive\_gps thread also handle SRF datas sent by the ultrasonic sensor.\\

We have created a small library with functions to receive udp datas. This library is described in the udp\_server.h file.\\

This function is reading udp datas on port 6444 (sent by the UAV).\\

\begin{lstlisting}

/*
   Start listening the buffers sent from uav
*/
int start_comm(void)
{
    udp_struct udp_uav;
    int msglen_uav;
  
    if(udpserver_init(&udp_uav,UDP_UAV,1)) diep("udp_UAV init");


    while (start_listen) {

	do {
	    msglen_uav = udpserver_receive(&udp_uav, buf_uav, 512);	   
	} while(msglen_uav<=0);
	
       record_data(buf_uav);

    }
  
    udpserver_close(&udp_uav);
    return 0;
}

\end{lstlisting}

Then, depending on whether it is a sensor or GPS data, we fill a structure.\\

\begin{lstlisting}  
int record_data(char *buf) {
  char *gprmc_begin = "$GPRMC";
  char *gpgga_begin = "$GPGGA";
  char *srfl_begin = "$SRFL";
  char *srfr_begin = "$SRFR";

  int ret_val = 0;

  if (!strncmp(gprmc_begin,buf,6)) {
    strncpy(ret_datas.gprmc_string,buf_uav,sizeof(ret_datas.gprmc_string));
    ret_val = 1;
  } else if (!strncmp(gpgga_begin,buf,6)) {
    strncpy(ret_datas.gpgga_string,buf_uav,sizeof(ret_datas.gpgga_string));
  } else if (!strncmp(srfl_begin,buf,5)) {
    ret_datas.srfl = atof(buf+6*sizeof(char));
  } else if (!strncmp(srfr_begin,buf,5)) {
    ret_datas.srfr = atof(buf+6*sizeof(char));
  } else {
    printf("ERROR NO STRING DETECTED\n");
  }
  return ret_val;
}
\end{lstlisting}

The other thread (receiving from target), uses similar functions.

\section{The target thread}

This thread contains functions related to auto-convergence. We have impleted different algorithms, described thereafter.\\

\subsection{Turn angle algorithm}

When it converges to the target, the UAV need to turn to an absolute angle between 0 et 360 from north. Depending on the UAV angle, it can be better to turn right, or to turn left, to reduce the turning duration.\\

The UAV will turn to reach the angle given as an argument. We have defined a tolerance. Indeed, because of transmission delays, the UAV can keep turning even if the angle is ok. A tolerance of 5.0 degrees is acceptable and always working.\\

\begin{lstlisting}
/*
  INPUT: angle   (float)
  tolerance (float)
  This function will make uav turn to the direction of target with an error of +- tolerance     
*/
void turn_angle2(float target_angle, float tol) {

  fdata sauv_ndata = get_ndata();
  float angle_360 = sauv_ndata.psi_current;
  float angle_inf, angle_sup;

  angle_inf = target_angle - tol;
  angle_sup = target_angle + tol;

  if (sauv_ndata.psi_current < 0) angle_360 = 360 + sauv_ndata.psi_current;
  if (target_angle < 0) target_angle += 360;

  if (target_angle > angle_360) {
     (target_angle - angle_360) < 180 ? send_order(turn_left,NULL) : send_order(turn_right,NULL);
  } else {
    (angle_360 - target_angle) < 180 ? send_order(turn_right,NULL) : send_order(turn_left,NULL);
  }

  while (!(sauv_ndata.psi_current > angle_inf && sauv_ndata.psi_current < angle_sup)) {
    sauv_ndata = get_ndata();
    usleep(100);
  }
  
  send_order(stop,NULL);
  sleep(1);
}
\end{lstlisting}

\subsection{Convergence algorithm  1}

Let's describe the first algorithm :\\

\begin{enumerate}

\item  Magneto calibration (the UAV has to be flying)
\item  Receive GPS datas
\item  Turn to wright angle
\item  Go forward 2 seconds
\item  If target reached, land otherwise, jump to step 3.

\end{enumerate}

\begin{lstlisting}
  if ( (landed == 1) && (calibration == 0) ){
    printf("start calibration\n");
    calibrate_magneto(NULL);
    sleep(4);
    calibration = 1;
    printf("Calibration done\n");
  }

  if ( (landed == 1) && (calibration == 1) && (mission == 0) ) {	  
    datas = get_comm_datas();	
    extract_coord(datas.gprmc_string,&depart);
   		
    datas_target = get_comm_datas_target();
   	
    if ((check_gps_coord_struc(&depart) > 0) && (check_gps_coord_struc(&datas_target.dest) > 0)) {
      navigation(&depart, &datas_target.dest, &distance, &angle, NULL); //&relatif_error
	
      turn_angle2(angle ,5.0);
		
      if (distance > 5.0){
	fprintf(redir_sortie,"La distance restante est %f\n",distance);
	fflush(redir_sortie);
	speed.power = 3;
	send_order(forward,(void *)&speed);
	sleep(3);
      } else { 
	send_order(land,NULL); 
	printf("LANDING \n");
	mission = 1;
      }	
    }
  }
\end{lstlisting}


\subsection{Convergence algorithm  2}

Let's describe the second algorithm :\\

\begin{enumerate}

\item  Magneto calibration (the UAV has to be flying)
\item  Receive GPS datas
\item  Turn to wright angle
\item  While distance is decreasing, go forward
\item  If target reached land, otherwise go to step 3.

\end{enumerate}

\begin{lstlisting}
  if ( (landed == 1) && (calibration == 0) ){
    printf("start calibration\n");
    calibrate_magneto(NULL);
    sleep(4);
    calibration = 1;
    printf("Calibration done\n");
  }

  if ( (landed == 1) && (calibration == 1) && (mission == 0) ) {	  
    datas = get_comm_datas();	
    extract_coord(datas.gprmc_string,&depart);

    datas_target = get_comm_datas_target();
	
    if ((check_gps_coord_struc(&depart) > 0) && (check_gps_coord_struc(&datas_target.dest) > 0)) {
      navigation(&depart, &datas_target.dest, &distance, &angle, NULL); //&relatif_error
	
      turn_angle2(angle ,5.0);
	
      while (last_distance > distance) {
	fprintf(redir_sortie,"La distance restante est %f\n",distance);
	fflush(redir_sortie);
	speed.power = 3;
	send_order(forward,(void *)&speed);
	last_distance = distance;
	sleep(1);
      }

      if (distance < 10.0){
	send_order(land,NULL); 
	printf("LANDING \n");
	mission = 1;
	fflush(redir_sortie);
	exit(0);
      }	
    }
  }
\end{lstlisting}

\section{GPS algorithms}

\subsection{GPRMC string}
After receive GPRMC strings sent from UAV, at the ground station, we can extract some necessaire informations such as coordinates GPS : latitude et longitude and data status.\\

The GPRMC sentence consists of twelve comma-delimited words:\\

\begin{verbatim}
$GPRMC,hhmmss.ss,A,llll.ll,a,yyyyy.yy,a,x.x,x.x,ddmmyy,x.x,a*hh
1    = UTC of position fix
2    = Data status (V=navigation receiver warning)
3    = Latitude of fix
4    = N or S
5    = Longitude of fix
6    = E or W
7    = Speed over ground in knots
8    = Track made good in degrees True
9    = UT date
10   = Magnetic variation degrees (Easterly var. subtracts from true course)
11   = E or W
12   = Checksum
\end{verbatim}

First, we check if Data status is valide (A) or not (V). If status is not valide, coordinate GPS will be set -1. Then we only interest in Latiude (3) and Longitude(5) data. We know also that the data of (4) and (6) are always N and E so the coordinate GPS is positive. For others informations, we don’t count in.\\

\begin{lstlisting}

void extract_coord( char str_gps[], struct gps_coordinate *point )
{
 char delims[] = ",";
 char *result;
 result = malloc(sizeof(char));
 int j,i = 0;
 result = strtok( str_gps, delims );

 char *degree ;
 degree = malloc(sizeof(char));
 char *minute ;
 minute = malloc(sizeof(char));

 while( i<6 )
   {
     i++;
     result = strtok( NULL, delims );                        
     //printf( "result is %d \"%s\"\n", i, result );                   
     if (!strcmp(result, "V") )//sortie la boucle quand GPS ne fonctionne pas
    { i = 7;
      point->longitude = -1.0;   
      point->latitude =  -1.0;   
      printf( "coordinates undetermined \n" );
    }

     if (i==3) //effecter la valeur de latitude
    {   
      for (j=0;j<2;j++) //extract degree
        {
          degree[j] = result[j];    
        }

      while (j< strlen(result)) //extract minute
        {
          minute[j-2] = result[j];
          j++;       
        }
      
      point->latitude = atof(degree) + atof(minute)/60.0 ;    /      if (point->latitude > 90.0 || point->latitude < -90.0) {
        point->latitude = -1.0;
        point->longitude = -1.0;
        
      }
      //printf( "latitude %f\n", point->latitude);
    }

     if (i==5) //effecter la valeur de longitude
    {   
      for (j=0;j<3;j++) //extract degree
        {
          degree[j] = result[j];    
        }

      while (j< strlen(result)) //extract minute
        {
          minute[j-3] = result[j];
          j++;       
        }
   
      point->longitude = atof(degree) + atof(minute)/60.0 ; //convert into degree
      if (point->longitude > 180.0 || point->longitude < -180.0) {
        point->latitude = -1.0;
        point->longitude = -1.0;
      }
      
          }            
   }
}
\end{lstlisting}

\subsection{Navigation}

\subsubsection{Bearing}

Bearing is the angle measured in a clockwise direction from the north line.
Thanks to this, we can know the direction to reach the target. The formula is given :

$$ \theta = atan2( sin(\Delta\lambda).cos(\phi2), cos(\phi1).sin(\phi2) − sin(\phi1).cos(\phi2).cos(\Delta\lambda) )$$

where $ \phi $  is latitude, $ \lambda $ is longitude.\\

\begin{lstlisting}

//calcul direction // North

y = sin(dest->longitude - depart->longitude) * cos(dest->latitude);

x = cos(depart->latitude)*sin(dest->latitude) - sin(depart->latitude)*cos(dest->latitude)*cos(dest->longitude - depart->longitude);

*angle = (atan2(y,x) * 180.0/M_PI);

\end{lstlisting}

\subsubsection{Distance}


We uses the ‘haversine’ formula to calculate the distance between two points – that is the shortest distance over the earth’s surface.

Haversine formula:

$$ a = sin^2(\Delta\phi/2) + cos(\phi1).cos(\phi2).sin^2(\Delta\lambda/2) $$

$$ c = 2.atan(\sqrt{a}, \sqrt{(1−a)})$$ 

$$ d = R.c $$

where $ \phi $ is latitude,

$ \lambda $ is longitude

\begin{lstlisting}
   // calcul distance
      x = sin((dest->latitude - depart->latitude)/2) * sin((dest->latitude - depart->latitude)/2) + sin((dest->longitude - depart->longitude)/2)*sin((dest->longitude - depart->longitude)/2) * cos(depart->latitude)*cos(dest->latitude);
     y = 2 * atan2(sqrt(x),sqrt(1-x));
     *distance = RAYON *y;
\end{lstlisting}

\begin{figure}[!h] 
\begin{center}
\includegraphics[width=10cm]{imgs/img.png}
\caption{Bearing angle} 
\label{img1} 
\end{center}
\end{figure} 

The point O is position of UAV, if we want to go to the point Q, we must turn to left an angle of 60° relative to the north. According to the formula above, it give us a negative angle -60° that means the point of destination is on the left. Another case, we have an angle of 65° on the right if we want to reach to the point P.
And the Haversine formula will also give us the distance of OQ or OP.